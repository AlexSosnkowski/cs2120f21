import .lecture_28
-- defines sum_up_to 

/-
The difference between simple case analysis and
induction is that induction let's us assume we 
are given an arbitrary number, n', and an answer
(value or proof) for n'. Have these objects is 
often the key to completing a proof,by giving a
formula that uses them to computing a result 
n'+1. 

Now we'll show where case analysis suffices to
prove that 0 is a left identity for addition as
we've defined it (because we've given the rule
for this case to the induction operation), but
where it will not work to prove that 0 is a 
right identity, For that, we'll need, and we'll
demonstrate, proof by induction.
-/

/-
Let's see Lean's definition of add.
-/

#check nat.add -- right click and go to definition

/-
Note that Lean's version uses recursion on the
second argument. So we have a rule for m + 0 and
a rule for m + n'.succ.
-/

/-
An easy proof that 0 is a left identity.
-/

example : ∀ (m : ℕ), nat.add m 0 = m :=
begin
  assume m,
  apply rfl, 
end

/- 
Why does case analysis fail in a proof that it's
also a right identity? Because we don't already
have a rule for that, as we did for the left case.
-/
example : ∀ (m : ℕ), add 0 m = m :=
begin
  assume m,
  apply rfl,          -- no rule for adding 0 on right!
  -- STUCK!
end

/-
... or are we?!

Proof by induction on n. 
-/

example : ∀ (n : ℕ), nat.add 0 n = n :=
begin
    assume n,
    induction n with n' ih,

/-
Π 
  {motive : ℕ → Sort u_1}, 
  motive 0 → 
  (Π (n : ℕ), motive n → motive n.succ) → 
  Π (n : ℕ), 
  motive n
-/

    -- base case, n = 0
    --simp [my_add],
    exact rfl,

    -- inductive 
    -- simplify using rules that define my_add
    -- my_add n'.succ 0 = n'.succ
    -- succ (my_add n' 0) = n'.succ
    simp [nat.add],
    /-
   Sullivan working to reduce unnecessary
   complexity in proof state as expressed.
    -/
    -- nat.rec 
      -- 0 
      -- (λ (n' : ℕ), nat.succ) 
      -- n'
    /-
    Application to n' of function
    defined by induction where (1)
    answer for 0 is 0, and (2) the
    answer for n'+1 is generated by
    succ, applied to n' is n'. But
    that's the induction hypothesis. 
    -/
    exact ih,
end
-- study these pretty extensiely, they are important  
example : ∀ (n : ℕ), nat.add n 0 = n :=
begin
    assume n,
    apply nat.rec_on n,

/-
Π 
  {motive : ℕ → Sort u_1}, 
  motive 0 → 
  (Π (n : ℕ), motive n → motive n.succ) → 
  Π (n : ℕ), 
  motive n
-/

    -- base case, n = 0
    --simp [my_add],
    exact rfl,

    -- inductive  case

    -- two arguments
      -- n'
      -- result for n'
    -- produce result for n'+1

    assume n' ih,

    /- 
    simplify application of my_add
    and further simplify resulting
    expression.
    -/
    simp [my_add],
    /-
    We will better explain what happens
    here and what the resulting goal is
    actually saying. REST IS STILL WORK
    IN PROGRESS.
    -/
    
    /- 
    (nat.rec 
      0 
      (λ (n' : ℕ), nat.succ)
    ) 
    n'
    -/

    /-
    Application to n' of function
    defined by induction where (1)
    answer for 0 is 0, and (2) the
    answer for n'+1 is generated by
    succ, applied to n' returns n'. 
    -/

    -- Simplify by definition of my_add
    -- in expression for induction hypothesis
    simp [my_add] at ih,

    /-
    It's clear that we've defined our
    second "machine".
    -/
    assumption,
end


/-
By induction 
P 0
∀ n, P n → P (n + 1)
assume 1 + 2 + ... + 2^n = 2^n+1 - 1
prove this property for n+1
prove 1 + 2 + 2^n + 2^n+1 =2^n+2 - 1
P(n + 1) = [1 + 2 + 2^n] + 2^n+1 = 2^n+1 - 1 + 2^n+1 = 2*2^n+1 - 1 = 2^n+2 - 1
-/

-- ∀ sets s, |s| = n, |P s| = 2^n
-- Proof by induction 
-- P n : ∀ set s, containing n elements the power set contains 2^n elemenets
-- ∀ n, P n
-- P 0, a set with zero elements is empty, and thus has one subset, itself, because all sets are subsets of themselves, this equals 2^0.
-- ∀ n if a set of size n has 2^n elements then a set of size n + 1 has 2^n+1
-- assume n : nat and size of n, 2^n
-- show set of n + 1 is 2^n+1
-- the number elements of h is 2^n, we double this when adding one element - the set of subsets with and without this new element
-- thus 2^n + 2^n = 2 * 2^n = 2^n+1


example : ∀(n : nat), sum_to (pow 2 n) → pow (2 (n+1)) - 1 := 
begin

end

-- α : Type
-- list α 
/-
list α
____________
| md list (α : Type) : Type
| nil : list
| cons (a : α)(t : list) -- con head and tail list - add a head to an old list

-/


